{"version":3,"file":"acejs.cjs.js","sources":["../src/ace-utils.js","../src/ace-di.js","../src/ace-reactivity.js","../src/ace-components.js"],"sourcesContent":["/**\r\n * Checks if a value is an object.\r\n * @param {*} val - The value to check.\r\n * @returns {boolean} - True if the value is an object, false otherwise.\r\n */\r\nexport function isObject(val) {\r\n    return val !== null && typeof val === 'object' && !Array.isArray(val);\r\n}\r\n\r\n/**\r\n * Converts a lower camelCase string to a valid attribute name.\r\n * @param {string} str - The camelCase string to convert.\r\n * @returns {string} - The converted attribute name.\r\n */\r\nexport function camelCaseToAttributeName(str) {\r\n    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\r\n}\r\n","/**\r\n * A simple dependency injection container.\r\n * Stores services by name and provides them when requested.\r\n */\r\nconst container = new Map();\r\n\r\n/**\r\n * Registers a class as a service in the dependency injection container.\r\n * @param {string} name - The name of the service.\r\n * @returns {ClassDecorator} - A decorator function for classes.\r\n */\r\nexport function Service(name) {\r\n    return function (target, context) {\r\n        if (context.kind !== 'class') {\r\n            throw new Error(\r\n                `@Service can only be used on classes, not on \"${context.kind}\"`\r\n            );\r\n        }\r\n        container.set(name, new target());\r\n    };\r\n}\r\n\r\n/**\r\n * Injects a service into a field or method.\r\n * @param {string} name - The name of the service to inject.\r\n * @returns {FieldDecorator|MethodDecorator} - A decorator function for fields or methods.\r\n */\r\nexport function Inject(name) {\r\n    return function (target, context) {\r\n        if (context.kind === 'field') {\r\n            return () => container.get(name);\r\n        } else if (context.kind === 'method') {\r\n            return function (...args) {\r\n                const service = container.get(name);\r\n                return target.apply(this, [...args, service]);\r\n            };\r\n        }\r\n    };\r\n}\r\n","import { isObject } from './ace-utils.js';\r\n\r\nconst dependenciesMap = new WeakMap();\r\nconst effectQueue = new Set();\r\nlet activeEffect = null;\r\nlet isBatching = false;\r\n\r\n/**\r\n * Tracks dependencies for reactive objects.\r\n * @param {Object} target - The reactive object.\r\n * @param {string|symbol} key - The property key being accessed.\r\n */\r\nfunction track(target, key) {\r\n    if (!activeEffect) return;\r\n\r\n    let dependencies = dependenciesMap.get(target);\r\n    if (!dependencies) {\r\n        dependencies = new Map();\r\n        dependenciesMap.set(target, dependencies);\r\n    }\r\n\r\n    let dependency = dependencies.get(key);\r\n    if (!dependency) {\r\n        dependency = new Set();\r\n        dependencies.set(key, dependency);\r\n    }\r\n\r\n    dependency.add(activeEffect);\r\n}\r\n\r\n/**\r\n * Triggers effects for a reactive object's property.\r\n * @param {Object} target - The reactive object.\r\n * @param {string|symbol} key - The property key being modified.\r\n */\r\nfunction trigger(target, key) {\r\n    const dependencies = dependenciesMap.get(target);\r\n    if (!dependencies) return;\r\n\r\n    const dependency = dependencies.get(key);\r\n    if (dependency) {\r\n        dependency.forEach((effectFn) => effectQueue.add(effectFn));\r\n    }\r\n\r\n    if (!isBatching) {\r\n        isBatching = true;\r\n        queueMicrotask(() => {\r\n            effectQueue.forEach((effectFn) => effectFn());\r\n            effectQueue.clear();\r\n            isBatching = false;\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a reactive proxy for an object.\r\n * @template T\r\n * @param {T} target - The target object to make reactive.\r\n * @param {{ deep?: boolean }} [options] - Options for reactivity.\r\n * @returns {T} - The reactive proxy.\r\n */\r\nexport function reactive(target, options) {\r\n    if (!isObject(target)) return target;\r\n\r\n    return new Proxy(target, {\r\n        get(obj, key, receiver) {\r\n            const result = Reflect.get(obj, key, receiver);\r\n\r\n            if (options?.deep && isObject(result)) {\r\n                return reactive(result, options);\r\n            }\r\n\r\n            track(obj, key);\r\n            return result;\r\n        },\r\n\r\n        set(obj, key, value, receiver) {\r\n            const prevValue = Reflect.get(obj, key, receiver);\r\n            if (prevValue === value) {\r\n                return true;\r\n            }\r\n\r\n            const result = Reflect.set(obj, key, value, receiver);\r\n\r\n            trigger(obj, key);\r\n            return result;\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Executes a reactive effect function.\r\n * @param {Function} fn - The effect function to execute.\r\n */\r\nfunction useEffect(fn) {\r\n    activeEffect = fn;\r\n    fn();\r\n    activeEffect = null;\r\n}\r\n\r\n/**\r\n * Creates a computed property that automatically updates when its dependencies change.\r\n * @param {Function} getter - The function to compute the value.\r\n * @returns {Proxy} - A reactive proxy for the computed value.\r\n */\r\nfunction computed(getter) {\r\n    let cachedValue;\r\n    let isDirty = true;\r\n\r\n    const effectFn = () => {\r\n        isDirty = true;\r\n        trigger(computedProxy, 'value');\r\n    };\r\n\r\n    const computedProxy = reactive({\r\n        get value() {\r\n            if (isDirty) {\r\n                activeEffect = effectFn;\r\n                cachedValue = getter();\r\n                activeEffect = null;\r\n                isDirty = false;\r\n            }\r\n            track(computedProxy, 'value');\r\n            return cachedValue;\r\n        },\r\n    });\r\n\r\n    return computedProxy;\r\n}\r\n\r\n/**\r\n * Creates a reactive reference for a primitive value or object.\r\n * @template T\r\n * @param {T} value - The initial value of the reference.\r\n * @returns {Object} - A reactive reference with a `value` property.\r\n */\r\nexport function ref(value) {\r\n    const refObject = reactive({ value });\r\n    return refObject;\r\n}\r\n\r\n/**\r\n * Decorator to create a reactive effect for a method.\r\n * @param {Function} target - The target method.\r\n * @param {Object} context - The context of the method.\r\n */\r\nexport function Effect(target, context) {\r\n    if (context.kind !== 'method') {\r\n        throw new Error(\r\n            `@Effect can only be used on methods, not on \"${context.kind}\"`\r\n        );\r\n    }\r\n\r\n    context.addInitializer(function () {\r\n        const boundEffect = target.bind(this);\r\n        queueMicrotask(() => useEffect(boundEffect));\r\n    });\r\n}\r\n\r\n/**\r\n * Decorator to make a class field reactive.\r\n * @param {Object} target - The target class.\r\n * @param {Object} context - The context of the field.\r\n * @returns {Function} - A function to initialize the reactive field.\r\n */\r\nexport function Reactive(target, context) {\r\n    if (context.kind !== 'field') {\r\n        throw new Error(\r\n            `@Reactive can only be used on fields, not on \"${context.kind}\"`\r\n        );\r\n    }\r\n\r\n    return (value, options = {}) => reactive(value, options);\r\n}\r\n\r\n/**\r\n * Decorator to create a computed property.\r\n * @param {Object} target - The target class.\r\n * @param {Object} context - The context of the field.\r\n */\r\nexport function Computed(target, context) {\r\n    if (context.kind !== 'field') {\r\n        throw new Error(\r\n            `@Computed can only be used on fields, not on \"${context.kind}\"`\r\n        );\r\n    }\r\n\r\n    context.addInitializer(function () {\r\n        const getter = this[context.name];\r\n        const computedValue = computed(getter.bind(this));\r\n\r\n        Object.defineProperty(this, context.name, {\r\n            get: () => computedValue.value,\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Decorator to make a class field a reactive reference.\r\n * @param {Object} target - The target class.\r\n * @param {Object} context - The context of the field.\r\n */\r\nexport function Ref(target, context) {\r\n    if (context.kind !== 'field') {\r\n        throw new Error(\r\n            `@Ref can only be used on fields, not on \"${context.kind}\"`\r\n        );\r\n    }\r\n\r\n    context.addInitializer(function () {\r\n        const initialValue = this[context.name];\r\n        const refValue = ref(initialValue);\r\n\r\n        Object.defineProperty(this, context.name, {\r\n            get: () => refValue.value,\r\n            set: (newValue) => {\r\n                refValue.value = newValue;\r\n            },\r\n        });\r\n    });\r\n}\r\n","import { reactive } from './ace-reactivity.js';\r\nimport { camelCaseToAttributeName } from './ace-utils.js';\r\n\r\nfunction propertyToAttribute(key, value) {\r\n    const attrName = camelCaseToAttributeName(key);\r\n    if (value === null || value === undefined) {\r\n        this.removeAttribute(attrName);\r\n    } else {\r\n        this.setAttribute(attrName, value.toString());\r\n    }\r\n}\r\n\r\n/**\r\n * Registers a class as a custom element.\r\n * @param {string} name - The name of the custom element.\r\n * @returns {ClassDecorator} - A decorator function for classes.\r\n */\r\nexport function CustomElement(name) {\r\n    return function (target, context) {\r\n        if (context.kind !== 'class') {\r\n            throw new Error(\r\n                `@CustomElement can only be used on classes, not on \"${context.kind}\"`\r\n            );\r\n        }\r\n\r\n        context.addInitializer(() => customElements.define(name, target));\r\n    };\r\n}\r\n\r\n/**\r\n * Binds a method to the instance of the class.\r\n * @param {Function} target - The target method.\r\n * @param {Object} context - The context of the method.\r\n * @returns {MethodDecorator} - A decorator function for methods.\r\n */\r\nexport function Bound(target, context) {\r\n    if (context.kind !== 'method') {\r\n        throw new Error(\r\n            `@Bound can only be used on methods, not on \"${context.kind}\"`\r\n        );\r\n    }\r\n\r\n    context.addInitializer(function () {\r\n        this[context.name] = this[context.name].bind(this);\r\n    });\r\n}\r\n\r\n/**\r\n * Makes a property reactive and reflects it to an attribute.\r\n * @param {Object} options - Options for the reflected property.\r\n * @param {Function} [options.converter] - A function to convert the attribute value to a property value.\r\n * @returns {PropertyDecorator} - A decorator function for properties.\r\n */\r\nexport function Reflected(target, context) {\r\n    if (context.kind !== 'field') {\r\n        throw new Error(\r\n            `@Reflected can only be used on fields, not on \"${context.kind}\"`\r\n        );\r\n    }\r\n\r\n    context.addInitializer(function () {\r\n        const key = context.name;\r\n        const refValue = reactive({ value: this[key] });\r\n        propertyToAttribute.call(this, key, refValue.value);\r\n\r\n        Object.defineProperty(this, key, {\r\n            get() {\r\n                return refValue.value;\r\n            },\r\n            set(value) {\r\n                const prevValue = refValue.value;\r\n                if (value === prevValue) return;\r\n\r\n                refValue.value = value;\r\n                propertyToAttribute.call(this, key, value);\r\n            },\r\n        });\r\n    });\r\n}\r\n"],"names":["isObject","val","_typeof","Array","isArray","container","Map","dependenciesMap","WeakMap","effectQueue","Set","activeEffect","isBatching","track","target","key","dependencies","get","set","dependency","add","trigger","forEach","effectFn","queueMicrotask","clear","reactive","options","Proxy","obj","receiver","result","Reflect","deep","value","propertyToAttribute","attrName","replace","toLowerCase","this","removeAttribute","setAttribute","toString","context","kind","Error","concat","addInitializer","name","bind","computedValue","getter","cachedValue","isDirty","computedProxy","computed","Object","defineProperty","customElements","define","boundEffect","fn","service","_len","arguments","length","args","_key","apply","undefined","initialValue","refValue","newValue","call"],"mappings":"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"}